# 微服务设计

## API Gateway

缺乏统一的出口暴露的问题

- 客户端到微服务直接通信， 强耦合
- 需要多次请求， 客户端聚合数据， 工作量巨大， 延迟高
- 协议不利于统一， 各个部门间有差异， 需要端来兼容。
- 面向”端“的API适配， 耦合到了内部服务
- 多终端兼容逻辑复杂，每个服务都需要处理
- 统一逻辑无法收敛， 安全认证、限流

增加app-interface用于统一的协议出口， 服务内进行dataset join,  按照业务场景设计粗粒度的 API

- 轻量交互： 协议精简、聚合
- 差异服务： 数据裁剪以及聚合、针对终端定制化API
- 动态升级： 原有系统兼容升级， 更新服务而非协议
- 沟通效率提升： 协作模式演进为移动业务+**网关小组**

BFF 可以认为是一种适配服务，将后端的微服务进行适配（主要包括聚合裁剪和格式适配等逻辑），向无线端设备暴露友好和统一的 API，方便无线设备接入访问后端服务。

app-interface 属于 single point of failure，严重代码缺陷或者流量洪峰可能引发集群宕机。

- 单个模块也会导致后续业务集成复杂度高， 根据康威法则， 单块的无线 BFF 和多团队之间就出现不匹配问题，团队之间沟通协调成本高，交付效率低下。
- 很多跨横切面逻辑，比如安全认证，日志监控，限流熔断等。随着时间的推移，代码变得越来越复杂，技术债越堆越多。

跨横切面（Cross-Cutting Concerns）的功能，需要协调更新框架升级发版（路由、认证、限流、安全），因此全部上沉，引入了 API Gateway，把业务集成度高的 BFF 层和通用功能服务层 API Gateway 进行了分层处理。

网关承担了重要的角色，它是解耦拆分和后续升级迁移的利器。在网关的配合下，单块 BFF 实现了解耦拆分，各业务线团队可以独立开发和交付各自的微服务，研发效率大大提升。另外，把跨横切面逻辑从 BFF 剥离到网关上去以后，BFF 的开发人员可以更加专注业务逻辑交付，实现了架构上的关注分离（Separation of Concerns）。

移动端 -> API Gateway -> BFF -> Microservices，在 FE Web业务中，BFF 可以是 Node.js 来做服务端渲染（SSR，Server-Side Rendering），注意这里忽略了上游的 CDN、4/7层负载均衡（ELB）。

## Microservices 划分

微服务架构时遇到的第一个问题就是如何划分服务的边界。在实际项目中通常会采用两种不同的方式划分服务边界，即通过业务职能（Business Capability）或是 DDD 的限界上下文（Bounded Context）。

- Business Capability    由公司内部不同部门提供的职能。例如客户服务部门提供客户服务的职能，财务部门提供财务相关的职能。
- Bounded Context    限界上下文是 DDD 中用来划分不同业务边界的元素，这里业务边界的含义是“解决不同业务问题”的问题域和对应的解决方案域，为了解决某种类型的业务问题，贴近领域知识，也就是业务。

CQRS，将应用程序分为两部分：命令端和查询端。命令端处理程序创建，更新和删除请求，并在数据更改时发出事件。查询端通过针对一个或多个物化视图执行查询来处理查询，这些物化视图通过订阅数据更改时发出的事件流而保持最新。

## Microservices 安全

对于外网的请求来说，我们通常在 API Gateway 进行统一的认证拦截，一旦认证成功，我们会使用 JWT 方式通过 RPC 元数据传递的方式带到 BFF 层，BFF 校验 Token 完整性后把身份信息注入到应用的 Context 中，BFF 到其他下层的微服务，建议是直接在 RPC Request 中带入用户身份信息(UserID)请求服务。

- API Gateway -> BFF -> Service 
  - Biz Auth -> JWT -> Request Args
- Full Trust
- Half Trust
- Zero Trust

