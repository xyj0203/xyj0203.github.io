# mysql最左索引前缀匹配为什么要这么设计

MySQL中的最左前缀匹配原则是基于B+树索引的工作原理和设计考虑而来的。

## 一、B+树索引的基本结构和特点

MySQL的InnoDB存储引擎使用B+树作为索引结构。**B+树是一种平衡的多路搜索树**，其特点是**叶子节点（leaf node）之间通过指针链接形成有序链表**，且所有非叶子节点不存储行数据，仅存储索引键值，而叶子节点存储了完整的行数据或指向行数据的指针。这样设计使得查询效率相对较高，尤其是在磁盘I/O密集型操作中。

## 二、联合索引

联合索引是指在一个索引中包含多个列，例如对`(col1, col2, col3)`建立联合索引，索引是按照最左列`col1`升序排序，对于相同的`col1`值，`col2`列再次升序排序，以此类推。

## 三、最左匹配原则

- **索引利用率**：由于B+树索引是按照索引列的顺序存储的，所以在索引中搜索时，自然可以从左至右依次匹配。只要查询条件中包含了索引的最左列，就可以利用索引来加速查询。而且，如果查询条件中包含了多个连续的索引列，还可以继续利用后面的列进行筛选，这就是所谓的最左前缀匹配。
- **索引紧凑性**：如果允许任意位置的列都可以独立使用索引，那么将极大地增加索引的大小和查询的复杂度。因为每列的组合都需要独立维护一个索引，这对于大型数据表来说，索引占用的空间和维护成本都会很高。
- **范围查询后的列不可用**：
  当查询条件中出现范围查询（如`col1 > value`）或者使用`LIKE 'value%'`这样的前缀匹配时，**B+树索引后续的列无法进行有效的排序和过滤，因为范围查询破坏了索引的有序性，因此在范围查询右侧的列无法利用索引进行检索。**

## 四、为什么会破坏B+树索引后续的列

当在B+树索引中执行范围查询时，例如针对一个联合索引 `(col1, col2, col3)` 执行如下查询：

```sql
SELECT * FROM table WHERE col1 = 'value1' AND col2 > 'value2';
```

这里对 `col2` 使用了范围查询条件 `col2 > 'value2'`。在这种情况下，MySQL 只能利用索引对 `col1` 的值进行精确匹配，接着对 `col2` 进行范围查找。然而，一旦进行了范围查找，B+树索引的有序性就被破坏了，因为范围内的 `col2` 值不再是连续的，无法像之前那样沿着索引的顺序进行高效的查找。

B+树的特性是叶子节点之间通过双向链表连接，对于某一列的范围查询，可以很快定位到范围起点并沿链表向下遍历直到范围终点。但是，如果我们在此基础上还要基于 `col3` 进行条件筛选，由于链表中的记录不再按照 `col3` 排序，所以数据库无法继续利用索引来快速找到符合条件的 `col3` 值，只能对查询结果进行回表（回到主键索引或聚簇索引），逐一检查每行记录的 `col3` 是否满足条件。

如果执行 `col1 = 'A' AND col2 > 'B3'` 的范围查询，数据库能快速定位到 `'B3'` 之后的记录。但是，如果还要根据 `col3` 查找，如 `col3 = 'C5'`，这时就需要逐行检查，因为索引并没有告诉我们 `'B3'` 之后哪些行的 `col3` 值是 `'C5'`。这就是为什么范围查询会破坏B+树索引后续列的有序性，使其无法继续参与高效索引查找的原因。