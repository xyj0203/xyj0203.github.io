# redis基本数据类型及底层数据结构

## 一、字符串

底层数据结构：简单动态字符串（SDS，Simple Dynamic String）
SDS 结构包含预分配的空间、实际存储的字符串长度和已使用的长度等信息，可以高效地执行字符串的追加、截取、长度计算等操作。

### SDS的设计思路是什么？

SDS（Simple Dynamic String）是Redis为了克服C语言传统字符串（以’\0’作为结束标志的字符数组）的一些局限性而设计的一种字符串数据结构。SDS的设计思路主要包括以下几个方面：

1. **动态扩容与缩容**：
   - SDS结构可以自动管理其容量，当字符串内容增长时，SDS会自动预留一部分空余空间，避免频繁的内存重分配操作。
   - 当字符串缩短时，SDS会记录未使用的空间大小，以便后续追加操作时重复利用。
2. **长度信息存储**：
   - SDS在结构中显式地存储了已使用空间长度（len）和未使用空间长度（free），因此获取字符串长度的操作时间复杂度为O(1)，不需要遍历整个字符串来寻找’\0’结束符。
3. **安全操作**：
   - SDS提供了安全的字符串API，可以防止缓冲区溢出，因为在进行字符串修改操作时，会先检查现有空间是否足够，不够时才会进行扩容。
4. **二进制安全**：
   - SDS可以存储包括’\0’在内的任何字节序列，不像C语言字符串遇到’\0’就会停止读取，因此它是二进制安全的。
5. **效率优化**：
   - SDS在内存分配时往往会进行适量的预分配，以减少将来可能发生的连续内存分配操作。
   - SDS的API设计考虑了字符串操作的常见场景，如追加、裁剪等，尽量减少内存拷贝，提升性能。

### 二、列表

底层数据结构：双端链表（linked list）或压缩列表（ziplist）

- 当列表元素数量较小且元素大小较小时，Redis 会使用压缩列表来节约内存；
- 当元素数量增大或元素大小超过一定阈值时，Redis 会转而使用双端链表，支持 O(1) 时间复杂度的头尾元素添加和删除操作。

## 列表list的设计思路

Redis的列表（List）数据类型设计思路主要聚焦于实现高效、灵活的双向链表结构，并结合内存管理策略以适应不同场景下的性能和空间需求。以下是Redis列表的主要设计特点：

1. **双向链表实现**：
   Redis的List底层采用双端链表（linked list）结构，每个链表节点包含数据和指向前后节点的指针。这种结构允许在列表的头部（左侧）和尾部（右侧）高效地执行插入（LPUSH/RPUSH）和删除（LPOP/RPOP）操作，时间复杂度均为O(1)。

2. **编码优化**：
   Redis为了优化内存使用，对于元素数量少且元素大小较小的列表，会选择使用压缩列表（ziplist）作为替代数据结构。压缩列表是一种连续内存区域，可以存储多个小尺寸元素，相比双端链表，它可以节省内存，尤其是当列表元素为空或元素很小的情况下。当列表的元素数量增长或元素大小超过阈值时，Redis会自动将列表编码转换为双端链表。

3. **批量操作**：
   Redis提供了一系列命令，如RPUSHX/LPUSHX、LINSERT、LTRIM等，支持对列表的多种批量操作，便于实现队列、消息传递等多种应用场景。

4. **空间优化**：
   Redis在内存管理上做了优化，例如在链表节点的分配上，采用内存池技术来复用和回收节点，减少内存碎片和分配次数。

   **内存池（Memory Pool）技术**是一种计算机程序设计中用于内存管理的方法，它通过预先分配一大块连续的内存空间，并将这块空间划分为大小相等或不等的小块单元，然后当程序需要动态分配和释放内存时，不再直接调用操作系统提供的内存分配函数（如malloc/free、new/delete等），而是从内存池中申请和归还内存块。这样做有以下几个优点：

   1. **提高内存分配效率**：由于内存池预先分配了内存，避免了频繁的系统调用，减少了内存分配和释放的开销，尤其是在小块内存频繁申请和释放的情况下，效果尤为明显。
   2. **减少内存碎片**：内存池可以按照预定的大小分配内存块，统一管理内存分配，从而减少因不同大小内存块分配和释放造成的内存碎片，提高内存利用率。
   3. **内存管理可控性增强**：内存池可以自定义分配策略，例如设定内存块的最大数量、预先分配多少内存等，增加了程序对内存管理的可控性和预见性。
   4. **便于错误检测**：通过内存池，可以更容易地跟踪内存的使用情况，当内存池耗尽时，可以迅速定位到问题，而不至于在整个系统层面排查内存泄漏等问题。
   5. **实时性增强**：在实时系统中，内存池技术能够提供确定性的内存分配时间，这对于那些对响应时间有严格要求的系统至关重要。

5. **迭代访问**：
   Redis通过LINDEX、LRANGE等命令提供了对列表元素的按索引访问和范围遍历能力，满足了用户对列表数据的不同访问需求。

6. **线程安全**：
   Redis作为一个单线程模型的数据库服务，内部对数据结构的操作是线程安全的，因此在多客户端并发访问和修改列表时，无需担心数据竞争问题。

## 三、集合

底层数据结构：整数集合（intset）或哈希表（hashtable）

- 当集合中的元素都是整数值并且元素数量较少时，Redis 会使用整数集合存储，这是一种有序的整数集合；
- 当元素数量增长或集合中有非整数值时，Redis 使用哈希表进行存储，实现高效的添加、删除和判断元素是否存在等操作。

### 集合的设计思路

1. **底层数据结构选择**：
   - 整数集合（intset）：当集合中所有元素都是整数且元素数量不大时，Redis使用整数集合存储。整数集合按照元素大小进行排序，并且不包含重复元素，这使得查找、添加和删除操作相对高效。
   - 哈希表（HashTable）：当集合元素数量增加或集合中有非整数值时，Redis将自动转换为哈希表存储。哈希表通过哈希函数将元素映射到桶中，实现O(1)平均时间复杂度的添加、删除和查找操作。
2. **唯一性保证**：
   Redis集合中的元素不允许重复，无论是整数集合还是哈希表，在添加元素时都会检查元素是否已存在于集合中，以确保集合的唯一性。
3. **集合操作丰富**：
   Redis提供了丰富的集合操作命令，如`SADD`（添加元素）、`SREM`（删除元素）、`SMEMBERS`（获取所有元素）、`SISMEMBER`（检查元素是否存在）、`SINTER`（求多个集合的交集）、`SUNION`（求多个集合的并集）等，这些操作在底层数据结构的基础上实现高效执行。
4. **内存优化**：
   - 对于整数集合，Redis采用紧凑的编码方式节省内存空间，例如，使用不同的位宽来存储整数，根据集合中元素的范围和数量自动调整存储结构。
   - 对于哈希表，Redis采用了适当的负载因子和自动扩容机制，既能保证查询效率，又能避免过早或过晚的内存分配。
5. **多态数据结构支持**：
   Redis还提供了有序集合（Sorted Set），它在集合的基础上增加了分数属性，使得集合内的元素能够按照分数进行排序。有序集合结合了集合和有序列表的优点，其底层数据结构是跳跃表（SkipList）和哈希表的组合。

## 四、有序集合

底层数据结构：跳跃表（skiplist）与哈希表的结合

- 有序集合中的每个元素都有一个分数（score），用于排序；
- 使用跳跃表实现有序排列，O(log N) 的时间复杂度完成插入、删除、查找操作；
- 同时使用哈希表存储元素到分数的映射关系，便于快速定位元素。

1. **底层数据结构**：
   Redis有序集合采用跳跃表（Skip List）作为主要的数据结构，跳跃表是一种随机化的数据结构，通过层级结构和多级索引实现高效的插入、删除和查找操作，时间复杂度接近于O(log N)。此外，有序集合还辅以哈希表（HashTable）进行成员到分值的映射，使得通过成员查找其分值和排名的时间复杂度也为O(1)。
2. **唯一性约束**：
   有序集合中的成员是唯一的，即使分值相同，也不能有重复的成员。在添加元素时，Redis会检查成员是否已存在，如果存在则更新分值。
3. **排序与范围查询**：
   根据成员的分值进行排序是有序集合的重要特征。跳跃表的层级结构支持高效的范围查询，例如返回分值在特定区间的所有成员，或者获取得分最高的几个成员。
4. **内存优化**：
   Redis对有序集合的内存管理进行了优化，比如当集合元素数量较少时，会使用压缩列表（ziplist）作为底层数据结构，以节省内存空间。当元素数量增长或元素大小超过阈值时，会自动转换为跳跃表和哈希表。
5. **丰富的操作命令**：
   提供了一系列操作命令，如`ZADD`（添加成员及其分值）、`ZSCORE`（获取成员的分值）、`ZRANGE`（按索引范围获取成员列表）、`ZREVRANGE`（按相反的排序顺序获取成员列表）、`ZCOUNT`（统计分值在指定范围内的成员数量）等，满足了多样化的业务需求。

## 五、哈希

底层数据结构：哈希表（hashtable）
Redis Hash 类型用于存储键值对集合，内部使用哈希表实现，可以方便地添加、删除和修改键值对，同时支持键的存在性判断和键值对的读取操作。

Redis Hash（哈希）数据结构的设计思路旨在实现一种可以存储键值对集合的数据类型，其设计重点在于高效、灵活和易用性，主要体现在以下几个方面：

1. **底层数据结构**：
   Redis Hash采用了两种底层数据结构实现：
   - 压缩列表（ziplist）：当哈希表中的键值对数量较小且每个键值对的值也较小（如长度较短的字符串）时，Redis会采用ziplist存储，ziplist是一种连续存储、空间利用率高的结构，可以减少内存碎片和提高内存访问效率。
   - 哈希表（hashtable）：当哈希表中的键值对数量增多或值的大小超过一定阈值时，Redis会自动转换为hashtable存储。hashtable使用哈希函数将键转化为哈希值，通过哈希值寻址，实现键值对的快速查找、插入和删除操作，时间复杂度通常为O(1)。
2. **键值对操作**：
   Redis Hash支持对键值对的多种操作，如`HSET`（设置键值对）、`HGET`（获取键对应的值）、`HDEL`（删除键值对）、`HEXISTS`（检查键是否存在）、`HKEYS`（获取所有键）、`HVALS`（获取所有值）等。这些操作均在底层数据结构的基础上进行优化，以保证高效执行。
3. **内存优化**：
   Redis Hash在内存管理上做了优化，例如，当哈希表的负载因子过高时，会自动进行rehash操作，调整哈希表的大小以维持较低的冲突率，提高查找效率。
4. **渐进式rehash**：
   在对哈希表进行扩容或缩容时，Redis采取了渐进式rehash策略，避免一次性转移大量键值对带来的阻塞风险，保证了其他客户端请求的正常处理。
5. **灵活应用场景**：
   Redis Hash可以用于实现多种应用场景，例如存储对象、缓存、计数器等。由于其键值对形式的特性，非常适合用于模拟关系数据库中的实体和属性，简化数据模型并提高访问速度。